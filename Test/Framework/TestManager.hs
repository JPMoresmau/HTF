--
-- Copyright (c) 2009-2012   Stefan Wehr - http://www.stefanwehr.de
--
-- This library is free software; you can redistribute it and/or
-- modify it under the terms of the GNU Lesser General Public
-- License as published by the Free Software Foundation; either
-- version 2.1 of the License, or (at your option) any later version.
--
-- This library is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-- Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public
-- License along with this library; if not, write to the Free Software
-- Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
--

{- |

This module defines function for running a set of tests. Furthermore,
it provides functionality for organzing tests into a hierarchical
structure. This functionality is mainly used internally in the code
generated by the @hftpp@ pre-processor.
-}

module Test.Framework.TestManager (

  module Test.Framework.TestTypes,

  -- * Running tests
  htfMain, runTest, runTestWithArgs, runTestWithOptions,

  -- * Organzing tests
  TestableHTF,

  makeQuickCheckTest, makeUnitTest, makeBlackBoxTest, makeTestSuite,
  makeAnonTestSuite,
  addToTestSuite, testSuiteAsTest,

) where

import Control.Monad
import Control.Monad.RWS
import System.Exit (ExitCode(..), exitWith)
import System.Environment (getArgs)
import Data.List ( isInfixOf, isPrefixOf, partition )
import qualified Data.List as List
import Data.Maybe (isJust)

import System.Directory (getTemporaryDirectory, removeFile)
import System.IO
import GHC.IO.Handle
import qualified Data.ByteString.Lazy as BSL

import qualified Test.HUnit.Lang as HU

import Test.Framework.Utils ( readM, ensureNewline )
import Test.Framework.TestManagerInternal
import Test.Framework.TestTypes
import Test.Framework.CmdlineOptions
import Test.Framework.TestReporter
import Test.Framework.Colors
import Test.Framework.Location

-- | Construct a test where the given 'Assertion' checks a quick check property.
-- See 'Test.Framework.QuickCheckWrapper'.
-- Mainly used internally.
makeQuickCheckTest :: TestID -> Location -> Assertion -> Test
makeQuickCheckTest id loc ass = BaseTest QuickCheckTest id (Just loc) ass

-- | Construct a unit test from the given 'IO' action.
-- See 'Test.Framework.HUnitWrapper'.
-- Mainly used internally.
makeUnitTest :: TestID -> Location -> IO a -> Test
makeUnitTest id loc ass = BaseTest UnitTest id (Just loc) (ass >> return ())

-- | Construct a black box test from the given 'Assertion'.
-- See 'Test.Framework.BlackBoxTest'.
-- Mainly used internally.
makeBlackBoxTest :: TestID -> Assertion -> Test
makeBlackBoxTest id ass = BaseTest BlackBoxTest id Nothing ass

-- | Create a named 'TestSuite' from a list of 'Test' values.
makeTestSuite :: TestID -> [Test] -> TestSuite
makeTestSuite = TestSuite

-- | Create an unnamed 'TestSuite' from a list of 'Test' values.
makeAnonTestSuite :: [Test] -> TestSuite
makeAnonTestSuite = AnonTestSuite

-- | Turn a 'TestSuite' into a proper 'Test'.
testSuiteAsTest :: TestSuite -> Test
testSuiteAsTest = CompoundTest

-- | Extend a 'TestSuite' with a list of 'Test' values
addToTestSuite :: TestSuite -> [Test] -> TestSuite
addToTestSuite (TestSuite id ts) ts' = TestSuite id (ts ++ ts')
addToTestSuite (AnonTestSuite ts) ts' = AnonTestSuite (ts ++ ts')

-- | A type class for things that can be run as tests.
-- Mainly used internally.
class TestableHTF t where
    flatten :: t -> [FlatTest]

instance TestableHTF Test where
    flatten = flattenTest Nothing

instance TestableHTF TestSuite where
    flatten = flattenTestSuite Nothing

instance TestableHTF t => TestableHTF [t] where
    flatten = concatMap flatten

instance TestableHTF (IO a) where
    flatten action = flatten (makeUnitTest "unnamed test" unknownLocation action)

type Path = Maybe String

flattenTest :: Path -> Test -> [FlatTest]
flattenTest path (BaseTest sort id mloc ass) =
    [FlatTest sort (path `concatPath` id) mloc ass]
flattenTest path (CompoundTest ts) =
    flattenTestSuite path ts

flattenTestSuite :: Path -> TestSuite -> [FlatTest]
flattenTestSuite path (TestSuite id ts) =
    concatMap (flattenTest (Just (path `concatPath` id))) ts
flattenTestSuite path (AnonTestSuite ts) =
    concatMap (flattenTest path) ts

concatPath :: Path -> String -> String
concatPath Nothing s = s
concatPath (Just s1) s2 = s1 ++ pathSep ++ s2
    where pathSep = ":"

runFlatTest :: FlatTest -> TR (RunResult, String)
runFlatTest ft =
    do reportTestStart ft
       res <- liftIO $ HU.performTestCase (ft_assertion ft)
       let (testResult, msg) =
             case res of
               Nothing -> (Pass, "")
               Just (isFailure, msg') ->
                   if ft_sort ft /= QuickCheckTest
                      then if isFailure
                              then case extractPendingMessage msg' of
                                     Nothing -> (Fail, msg')
                                     Just msg'' -> (Pending, msg'')
                              else (Error, msg')
                      else case readM msg' :: Maybe (TestResult, Maybe String) of
                             Nothing ->
                                 error ("INTERNAL HTF ERROR: " ++
                                        "Cannot deserialize QuickCheck " ++
                                        "error message.\n[BEGIN]\n" ++
                                        show msg' ++ "\n[END]\n")
                             Just (r, ms) ->
                                 case ms of
                                   Nothing -> (r, "")
                                   Just s -> (r, s)
           rr = RunResult
                  { rr_sort = ft_sort ft
                  , rr_id = ft_id ft
                  , rr_location = ft_location ft
                  , rr_result = testResult }
       return (rr, msg)

handleRunResult :: (RunResult, String) -> TR ()
handleRunResult (rr, msg) =
    do modify (\s -> s { ts_results = rr : ts_results s })
       reportTestResult rr msg

runAllFlatTests :: [FlatTest] -> TR ()
runAllFlatTests tests =
    do reportGlobalStart tests
       mapM_ (\ft -> runFlatTest ft >>= handleRunResult) tests

-- | Run something testable using the 'Test.Framework.TestConfig.defaultCmdlineOptions'.
runTest :: TestableHTF t => t              -- ^ Testable thing
                         -> IO ExitCode    -- ^ See 'runTestWithOptions' for a specification of the 'ExitCode' result
runTest = runTestWithOptions defaultCmdlineOptions

-- | Run something testable, parse the 'CmdlineOptions' from the given commandline arguments.
runTestWithArgs :: TestableHTF t => [String]        -- ^ Commandline arguments
                                 -> t               -- ^ Testable thing
                                 -> IO ExitCode     -- ^ See 'runTestWithConfig' for a specification of the 'ExitCode' result
runTestWithArgs args t =
    case parseTestArgs args of
      Left err ->
          do hPutStrLn stderr err
             return $ ExitFailure 1
      Right opts ->
          runTestWithOptions opts t

-- | Runs something testable with the given 'CmdlineOptions'.
-- See 'runTestWithConfig' for a specification of the 'ExitCode' result.
runTestWithOptions :: TestableHTF t => CmdlineOptions -> t -> IO ExitCode
runTestWithOptions opts t =
    if opts_help opts
       then do hPutStrLn stderr helpString
               return $ ExitFailure 1
       else do tc <- testConfigFromCmdlineOptions opts
               if opts_listTests opts
                  then let fts = filter (opts_filter opts) (flatten t)
                       in do runRWST (reportAllTests fts) tc initTestState
                             return ExitSuccess
                  else runTestWithConfig tc t

-- | Runs something testable with the given 'TestConfig'.
-- The result is 'ExitSuccess' if all tests were executed successfully,
-- 'ExitFailure' otherwise. In the latter case, an error code of @1@ indicates
-- that failures but no errors occurred, otherwise the error code @2@ is used.
--
-- A test is /successful/ if the test terminates and no assertion fails.
-- A test is said to /fail/ if an assertion fails but no other error occur.
runTestWithConfig :: TestableHTF t => TestConfig -> t -> IO ExitCode
runTestWithConfig tc t =
     do (_, s, _) <- runRWST (runAllFlatTests (filter (tc_filter tc) (flatten t))) tc initTestState
        let results = reverse (ts_results s)
            passed = filter (\rr -> rr_result rr == Pass) results
            pending = filter (\rr -> rr_result rr == Pending) results
            failed = filter (\rr -> rr_result rr == Fail) results
            error = filter (\rr -> rr_result rr == Error) results
        runRWST (reportGlobalResults passed pending failed error) tc (TestState [])
        return $ case () of
                   _| length failed == 0 && length error == 0 -> ExitSuccess
                    | length error == 0 -> ExitFailure 1
                    | otherwise -> ExitFailure 2

-- | Runs something testable by parsing the commandline arguments as test options
-- (using 'parseTestArgs'). Exits with the exit code returned by 'runTestWithArgs'.
-- This function is the main entry point for running tests.
htfMain :: TestableHTF t => t -> IO ()
htfMain tests =
    do args <- getArgs
       ecode <- runTestWithArgs args tests
       exitWith ecode
